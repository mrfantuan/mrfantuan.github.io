---
layout: post
title: 理解字节序
date:   2017-07-07 11:00:00
categories: 计算机理解
tag: 计算机理解
---
# 前言
引用百度词条的定义:
> 字节序，即字节在电脑中存放时的序列与输入（输出）时的序列是先到的在前还是后到的在前。

# 理解字节序
## 字节序

计算机硬件有两种存储方式：
> `大端字节序(big endian)`
> `小端字节序(little endian)`

![endian](/images/endianness-1-1.png)

同理，0x1234567的大端序和小端序的写法如下图:

![endian](/images/endianness-1-2.png)

我一直不是很理解，为什么要有字节序，每次读写都要区分，多麻烦！统一使用大端序岂不是更方便？后来发现我的理解是错的，字节序其实很简单。

## 浅谈
首先为什么要有小端字节序？

答案是，计算机电路优先处理低位字节效率比较高，因为计算机都是从低位开始的，所以计算机内部都是小端字节序，但是人类习惯是大端字节序。所以除了计算机内部处理，其他场合几乎都是大端字节序，比如网络传输、文件存储。

计算机处理字节序的时候，不知道什么是高位字节低位字节，他只知道按照顺序读取字节，先读一个字节再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。

字节序的处理其实就一句话
> 只有读取的时候，才必须区分字节序，其他情况都不用考虑。

处理器读取外部数据的时候，必须知道数据的字节序，再将其转换成正确的值。然后，就正常使用着值，完后不用再考虑字节序问题。即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序问题。

## 事例
举例来说，处理器读取一个16位整数的时候，如果是大端字节序，就按照下面的方式转换成值：
```c++
x = buf[offset] * 256 + buf[offset+1];
```
上面代码中，buf是整个数据块在内存中的起始地址，offset是当前正在读取的位置。第一个字节乘以256，在加上第二个字节，就是大端字节序的值，这个式子也可以用逻辑运算符改写。
```c++
x = buf[offset]<<8 | buf[offset+1];
```
上面代码中，第一个字节左移8位（即后面添8个0），然后再与第二个字节进行或运算。

---
如果是小端字节序，用下面的公式转成值。
```c++
x = buf[offset+1] * 256 + buf[offset];
```

---
32位整数的求值公式也是一样的。

```c++
/* 大端字节序 */
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24);

/* 小端字节序 */
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
```
